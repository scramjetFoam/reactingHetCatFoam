/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  10
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     1.0;
    format      ascii;
    class       volVectorField;
    location    "0";
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 1 -1 0 0 0 0];

internalField	uniform	(0 0 0.0);

boundaryField
{
    inlet
    {
        // type    fixedValue;
	    // value	uniform (0.000 0 0.0);
        // type            zeroGradient;
        type            codedMixed;
        refValue        uniform (0 0 0);
        refGradient     uniform (0 0 0);
        valueFraction   uniform 1;
        value           uniform (0 0 0);
        name            UfixedVal;
        code            #{
            // vector UC = vector(0.00014, 0.0, 0.0);
            // vector UC = vector(1.2e-4, 0.0, 0.0);
            // vector UC = vector(1.2e-4, 0.0, 0.0);

            // NOTE: calculate this from the initial value on the patch
            dimensionedScalar MgC("MgC", dimMass/dimMoles, 0.039729);

            const fvPatch& boundaryPatch = patch();
            const fvBoundaryMesh& boundaryMesh = boundaryPatch.boundaryMesh();
            const fvMesh& mesh = boundaryMesh.mesh();
            const scalarField& delta = patch().deltaCoeffs();
            volVectorField mD = ((mesh.lookupObject<volVectorField>("mD")));
            volScalarField rho = ((mesh.lookupObject<volScalarField>("rho")));
            volScalarField Mg = ((mesh.lookupObject<volScalarField>("Mg")));
            // volVectorField UD = (mD/rho);
            volVectorField UD = ((mesh.lookupObject<volVectorField>("UD")));




            // surfaceVectorField mDbyRhoSNGrad ( fvc::snGrad(mD / rho) );
            // volScalarField Mg = ((mesh.lookupObject<volScalarField>("Mg")));
            // surfaceVectorField MgS = fvc::interpolate(U) * (fvc::snGrad(Mg) / fvc::interpolate(Mg)); 
            // surfaceScalarField mDF = (mesh.lookupObject<surfaceScalarField>("mDF")); 
            // surfaceScalarField UDF = mDF / fvc::interpolate(rho); 


            // surfaceScalarField UDF = ("UDF", dimLength/dimTime, vector(mDF / fvc::interpolate(rho), 0, 0); 
            // surfaceVectorField UDFS = (mesh.lookupObject<surfaceVectorField>("UDFS")); 

            // surfaceScalarField MgS = (fvc::interpolate(MgC / Mg));
            // volVectorField UDV = ((mesh.lookupObject<volVectorField>("UD")));
            // surfaceVectorField UDS = (fvc::interpolate(UDV));
            //~ //const volScalarField& lambda((mesh.lookupObject<volScalarField>("lambda")));
            //~ scalar lambda = 90.0;
            // const scalarField& lambdaTu = patch().lambda();
            // scalar lambdaNikl = 90;
            //~ scalar alpha_L = 150.0;
            //~ //scalar alpha_L = 10;
            //~ //dimensionedScalar alpha_L("alpha_L",dimensionSet( 0, -1, 0, 0, 0, 0, 0),150);
            // this->refValue() = UC + UDS.boundaryField()[patch().index()];
            // this->refValue() = MgS.boundaryField()[patch().index()];

            // forAll(this->refValue(), refVal)
            // {
                // forAll(this->refValue()[refVal], BC)
                // {
            this->refValue()= UD.boundaryField()[patch().index()];
                // }
            // }

            // this->refValue() = 
            // this->refValue() = UC;
            
            // this->refValue() = UDS.boundaryField()[patch().index()];
            // this->refValue() = UC * MgS.boundaryField()[patch().index()];
            // this->refGrad() = mDbyRhoSNGrad.boundaryField()[patch().index()];
            //~ //this->valueFraction() = 1.0/(1+lambda/(alpha_L/delta));
            // this->valueFraction() = 1.0/(1.0+(kappa+kappaG*epsEff)/(1500.0/delta));
            //~ this->valueFraction() = 1e-5;
        #};

        codeInclude
        #{
            #include "fvCFD.H"
        #};

        codeOptions
        #{
            -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(LIB_SRC)/meshTools/lnInclude \
            -I$(LIB_SRC)/sampling/lnInclude
        #};
    }
    
    outlet
    {
        // type    fixedValue;
        // type fluxCorrectedVelocity;
        type            zeroGradient;
//         phi             phi;
//         rho             rho;

//         type            codedMixed;
//         refValue        uniform (0 0 0);
//         refGradient     uniform (0 0 0);
//         valueFraction   uniform 0;
//         value           uniform (0 0 0);
//         name            UZerGrad;
//         code            #{
//             // vector UC = (0.1 0 0);
//             dimensionedVector UC("UC", dimLength/dimTime, vector(0.01, 0, 0));
//             const fvPatch& boundaryPatch = patch();
//             const fvBoundaryMesh& boundaryMesh = boundaryPatch.boundaryMesh();
//             const fvMesh& mesh = boundaryMesh.mesh();
//             const scalarField& delta = patch().deltaCoeffs();
//             volVectorField U = ((mesh.lookupObject<volVectorField>("U")));
//             volVectorField UCF = U*0 + UC;
//             volScalarField rho = ((mesh.lookupObject<volScalarField>("rho")));
//             // surfaceVectorField mDbyRhoSNGrad ( - fvc::snGrad(rho) * fvc::interpolate( UCF / rho));
//             surfaceVectorField mDbyRhoSNGrad ( fvc::interpolate( UCF ) );
//             // volVectorField UD = ((mesh.lookupObject<volVectorField>("UD")));
//             // surfaceVectorField snGradUD = fvc::snGrad(UD);
//             // surfaceVectorField UD = (fvc::interpolate(mD/rho));
//             //~ //const volScalarField& lambda((mesh.lookupObject<volScalarField>("lambda")));
//             //~ scalar lambda = 90.0;
//             // const scalarField& lambdaTu = patch().lambda();
//             // scalar lambdaNikl = 90;
//             //~ scalar alpha_L = 150.0;
//             //~ //scalar alpha_L = 10;
//             //~ //dimensionedScalar alpha_L("alpha_L",dimensionSet( 0, -1, 0, 0, 0, 0, 0),150);
//             // this->refValue() = UD.boundaryField()[patch().index()];
//             this->refGrad() = mDbyRhoSNGrad.boundaryField()[patch().index()];
//             //~ //this->valueFraction() = 1.0/(1+lambda/(alpha_L/delta));
//             // this->valueFraction() = 0;
//             //~ this->valueFraction() = 1e-5;
//         #};

//         codeInclude
//         #{
//             #include "fvCFD.H"
//         #};

//         codeOptions
//         #{
//             -I$(LIB_SRC)/finiteVolume/lnInclude \
//             -I$(LIB_SRC)/meshTools/lnInclude \
//             -I$(LIB_SRC)/sampling/lnInclude
//         #};
//     }
    
//    cylinder 
//     {
//         // type    noSlip;
//         type empty;
//     }
//     sides
//     {
//         type    slip;
//     }
}


// ************************************************************************* //

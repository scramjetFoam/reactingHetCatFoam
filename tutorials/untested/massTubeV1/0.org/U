/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  10
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     1.0;
    format      ascii;
    class       volVectorField;
    location    "0";
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 1 -1 0 0 0 0];

internalField	uniform	(0 0 0.0);

boundaryField
{
    inlet
    {
        // type    fixedValue;
	    // value	uniform (0.000 0 0.0);
        // type            zeroGradient;
        type            codedMixed;
        refValue        uniform (0 0 0);
        refGradient     uniform (0 0 0);
        valueFraction   uniform 1;
        value           uniform (0 0 0);
        name            UfixedVal;
        code            #{
            vector UC = vector(0.0, 0.0, 0.0);
            // dimensionedScalar MgC("MgC", dimMass/dimMoles, 0.039729);

            const fvPatch& boundaryPatch = patch();
            const fvBoundaryMesh& boundaryMesh = boundaryPatch.boundaryMesh();
            const fvMesh& mesh = boundaryMesh.mesh();
            const scalarField& delta = patch().deltaCoeffs();

            volVectorField UD = (mesh.lookupObject<volVectorField>("UD"));

            this->refValue()= UC + UD.boundaryField()[patch().index()];
        #};

        codeInclude
        #{
            #include "fvCFD.H"
        #};

        codeOptions
        #{
            -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(LIB_SRC)/meshTools/lnInclude \
            -I$(LIB_SRC)/sampling/lnInclude
        #};
    }
    
    outlet
    {
        // type    fixedValue;
        // type fluxCorrectedVelocity;
        type            zeroGradient;
//         phi             phi;
//         rho             rho;

//         type            codedMixed;
//         refValue        uniform (0 0 0);
//         refGradient     uniform (0 0 0);
//         valueFraction   uniform 0;
//         value           uniform (0 0 0);
//         name            UZerGrad;
//         code            #{
//             // vector UC = (0.1 0 0);
//             dimensionedVector UC("UC", dimLength/dimTime, vector(0.01, 0, 0));
//             const fvPatch& boundaryPatch = patch();
//             const fvBoundaryMesh& boundaryMesh = boundaryPatch.boundaryMesh();
//             const fvMesh& mesh = boundaryMesh.mesh();
//             const scalarField& delta = patch().deltaCoeffs();
//             volVectorField U = ((mesh.lookupObject<volVectorField>("U")));
//             volVectorField UCF = U*0 + UC;
//             volScalarField rho = ((mesh.lookupObject<volScalarField>("rho")));
//             // surfaceVectorField mDbyRhoSNGrad ( - fvc::snGrad(rho) * fvc::interpolate( UCF / rho));
//             surfaceVectorField mDbyRhoSNGrad ( fvc::interpolate( UCF ) );
//             // volVectorField UD = ((mesh.lookupObject<volVectorField>("UD")));
//             // surfaceVectorField snGradUD = fvc::snGrad(UD);
//             // surfaceVectorField UD = (fvc::interpolate(mD/rho));
//             //~ //const volScalarField& lambda((mesh.lookupObject<volScalarField>("lambda")));
//             //~ scalar lambda = 90.0;
//             // const scalarField& lambdaTu = patch().lambda();
//             // scalar lambdaNikl = 90;
//             //~ scalar alpha_L = 150.0;
//             //~ //scalar alpha_L = 10;
//             //~ //dimensionedScalar alpha_L("alpha_L",dimensionSet( 0, -1, 0, 0, 0, 0, 0),150);
//             // this->refValue() = UD.boundaryField()[patch().index()];
//             this->refGrad() = mDbyRhoSNGrad.boundaryField()[patch().index()];
//             //~ //this->valueFraction() = 1.0/(1+lambda/(alpha_L/delta));
//             // this->valueFraction() = 0;
//             //~ this->valueFraction() = 1e-5;
//         #};

//         codeInclude
//         #{
//             #include "fvCFD.H"
//         #};

//         codeOptions
//         #{
//             -I$(LIB_SRC)/finiteVolume/lnInclude \
//             -I$(LIB_SRC)/meshTools/lnInclude \
//             -I$(LIB_SRC)/sampling/lnInclude
//         #};
    }
    
   cylinder 
    {
        type    noSlip;
        // type empty;
    }
//     sides
//     {
//         type    slip;
//     }
}


// ************************************************************************* //
